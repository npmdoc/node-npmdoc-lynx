<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dscape/lynx">lynx (v0.2.0)</a>
</h1>
<h4>Minimalistic StatsD client for Node.js programs</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx">module lynx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx">
            function <span class="apidocSignatureSpan"></span>lynx
            <span class="apidocSignatureSpan">(host, port, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.sample">
            function <span class="apidocSignatureSpan">lynx.</span>sample
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.super_">
            function <span class="apidocSignatureSpan">lynx.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">lynx.</span>lynx.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx.lynx">module lynx.lynx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.lynx">
            function <span class="apidocSignatureSpan">lynx.</span>lynx
            <span class="apidocSignatureSpan">(host, port, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.sample">
            function <span class="apidocSignatureSpan">lynx.lynx.</span>sample
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.super_">
            function <span class="apidocSignatureSpan">lynx.lynx.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx.lynx.prototype">module lynx.lynx.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype._default_error_handler">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_default_error_handler
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype._update_last_used">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_update_last_used
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.close">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.count">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>count
            <span class="apidocSignatureSpan">(stats, delta, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.createTimer">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>createTimer
            <span class="apidocSignatureSpan">(stat, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.decrement">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>decrement
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.destroy">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.end">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>end
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.gauge">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>gauge
            <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.increment">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>increment
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.send">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>send
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.set">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>set
            <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.timing">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>timing
            <span class="apidocSignatureSpan">(stat, duration, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.write">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>write
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx" id="apidoc.module.lynx">module lynx</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx" id="apidoc.element.lynx.lynx">
        function <span class="apidocSignatureSpan"></span>lynx
        <span class="apidocSignatureSpan">(host, port, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lynx(host, port, options) {
  if (!(this instanceof Lynx)) {
    return new Lynx(host, port, options);
  }

  var self = this;

  //
  // Server hostname and port
  //
  this.host = host || '127.0.0.1';
  this.port = port || 8125;

  //
  // Optional shared socket
  //
  this.socket = options &amp;&amp; options.socket;

  //
  // Handle prefix
  //
  this.scope = options &amp;&amp; options.scope || options &amp;&amp; options.prefix || '';

  //
  // groups in graphite are delimited by `.` so we need to make sure our
  // scope ends with `.`. If it doesn't we just add it (unless we have no
  // scope defined).
  //
  if(typeof this.scope === 'string' &amp;&amp; this.scope !== '' &amp;&amp;
     !/\.$/.test(this.scope)) {
    this.scope += '.';
  }

  //
  // When a *shared* socked isn't provided, an ephemeral
  // socket is demand allocated.  This ephemeral socket is closed
  // after being idle for EPHEMERAL_LIFETIME_MS.
  //
  this.ephemeral_socket = undefined;
  this.last_used_timer  = undefined;

  //
  // Set out error handling code
  //
  this.on_error = options &amp;&amp; typeof options.on_error === 'function'
               ? options.on_error
               : this._default_error_handler
               ;

  //
  // Stream properties
  //
  this.readable = true;
  this.writable = true;

  this.parser = parser.createStream();

  this.parser.on('error', this.on_error);

  this.parser.on('stat', function (text, stat_obj) {
    var stat = {};

    //
    // Construct a statsd value|type pair
    //
    stat[stat_obj.stat] = stat_obj.value + '|' + stat_obj.type;

    //
    // Add sample rate if one exists
    //
    if(stat_obj.sample_rate) {
      stat[stat_obj.stat] += '@' + stat_obj.sample_rate;
      self.send(stat, parseFloat(stat_obj.sample_rate));
    }
    else {
      self.send(stat);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.sample" id="apidoc.element.lynx.sample">
        function <span class="apidocSignatureSpan">lynx.</span>sample
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(stats, sample_rate) {
  //
  // If we don't have a sample rate between 0 and 1
  //
  if (typeof sample_rate !== 'number' || sample_rate &gt; 1 || sample_rate &lt; 0) {
    //
    // Had to ignore the invalid sample rate
    // Most of the times this is because sample_rate is undefined
    //
    return stats;
  }

  var sampled_stats = {};

  //
  // Randomly determine if we should sample this specific instance
  //
  if (mt.genrand_real2(0,1) &lt;= sample_rate) {
    //
    // Note: Current implementation either sends all stats for a specific
    //       sample rate or sends none. Makes one wonder if granularity
    //       should be at the individual stat level
    //
    Object.keys(stats).forEach(function construct_sampled(stat) {
      var value = stats[stat];
      sampled_stats[stat] = value + '|@' + sample_rate;
    });
  }

  return sampled_stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.super_" id="apidoc.element.lynx.super_">
        function <span class="apidocSignatureSpan">lynx.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx.lynx" id="apidoc.module.lynx.lynx">module lynx.lynx</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx.lynx" id="apidoc.element.lynx.lynx.lynx">
        function <span class="apidocSignatureSpan">lynx.</span>lynx
        <span class="apidocSignatureSpan">(host, port, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lynx(host, port, options) {
  if (!(this instanceof Lynx)) {
    return new Lynx(host, port, options);
  }

  var self = this;

  //
  // Server hostname and port
  //
  this.host = host || '127.0.0.1';
  this.port = port || 8125;

  //
  // Optional shared socket
  //
  this.socket = options &amp;&amp; options.socket;

  //
  // Handle prefix
  //
  this.scope = options &amp;&amp; options.scope || options &amp;&amp; options.prefix || '';

  //
  // groups in graphite are delimited by `.` so we need to make sure our
  // scope ends with `.`. If it doesn't we just add it (unless we have no
  // scope defined).
  //
  if(typeof this.scope === 'string' &amp;&amp; this.scope !== '' &amp;&amp;
     !/\.$/.test(this.scope)) {
    this.scope += '.';
  }

  //
  // When a *shared* socked isn't provided, an ephemeral
  // socket is demand allocated.  This ephemeral socket is closed
  // after being idle for EPHEMERAL_LIFETIME_MS.
  //
  this.ephemeral_socket = undefined;
  this.last_used_timer  = undefined;

  //
  // Set out error handling code
  //
  this.on_error = options &amp;&amp; typeof options.on_error === 'function'
               ? options.on_error
               : this._default_error_handler
               ;

  //
  // Stream properties
  //
  this.readable = true;
  this.writable = true;

  this.parser = parser.createStream();

  this.parser.on('error', this.on_error);

  this.parser.on('stat', function (text, stat_obj) {
    var stat = {};

    //
    // Construct a statsd value|type pair
    //
    stat[stat_obj.stat] = stat_obj.value + '|' + stat_obj.type;

    //
    // Add sample rate if one exists
    //
    if(stat_obj.sample_rate) {
      stat[stat_obj.stat] += '@' + stat_obj.sample_rate;
      self.send(stat, parseFloat(stat_obj.sample_rate));
    }
    else {
      self.send(stat);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.sample" id="apidoc.element.lynx.lynx.sample">
        function <span class="apidocSignatureSpan">lynx.lynx.</span>sample
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(stats, sample_rate) {
  //
  // If we don't have a sample rate between 0 and 1
  //
  if (typeof sample_rate !== 'number' || sample_rate &gt; 1 || sample_rate &lt; 0) {
    //
    // Had to ignore the invalid sample rate
    // Most of the times this is because sample_rate is undefined
    //
    return stats;
  }

  var sampled_stats = {};

  //
  // Randomly determine if we should sample this specific instance
  //
  if (mt.genrand_real2(0,1) &lt;= sample_rate) {
    //
    // Note: Current implementation either sends all stats for a specific
    //       sample rate or sends none. Makes one wonder if granularity
    //       should be at the individual stat level
    //
    Object.keys(stats).forEach(function construct_sampled(stat) {
      var value = stats[stat];
      sampled_stats[stat] = value + '|@' + sample_rate;
    });
  }

  return sampled_stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.super_" id="apidoc.element.lynx.lynx.super_">
        function <span class="apidocSignatureSpan">lynx.lynx.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx.lynx.prototype" id="apidoc.module.lynx.lynx.prototype">module lynx.lynx.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype._default_error_handler" id="apidoc.element.lynx.lynx.prototype._default_error_handler">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_default_error_handler
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _default_error_handler(e) {
  this.emit('error', e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype._update_last_used" id="apidoc.element.lynx.lynx.prototype._update_last_used">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_update_last_used
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _update_last_used() {
  var self = this;

  //
  // Only update on the ephemeral socket
  //
  if (this.ephemeral_socket) {
    //
    // Clear existing timeouts
    //
    if (this.last_used_timer) {
      clearTimeout(this.last_used_timer);
    }

    //
    // Update last_used_timer
    //
    this.last_used_timer = setTimeout(function() {
      //
      // If we have an open socket close it
      //
      if (self.ephemeral_socket) {
        self.ephemeral_socket.close();
      }

      //
      // Delete the socket
      //
      delete self.ephemeral_socket;
    }, EPHEMERAL_LIFETIME_MS);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.close" id="apidoc.element.lynx.lynx.prototype.close">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close() {
  //
  // User defined socket
  //
  if (this.socket) {
    this.socket.close();
    this.socket = undefined;
  }

  //
  // Ephemeral socket
  //
  if (this.ephemeral_socket) {
    this.ephemeral_socket.close();
    this.ephemeral_socket = undefined;
  }

  //
  // Timer
  //
  if (this.last_used_timer) {
    clearTimeout(this.last_used_timer);
    this.last_used_timer = undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , "baz" : "500|ms"  // timing
  , "boaz": "40|s"    // set
  }, 0.1);            // sample rate at `0.1`
```

### Closing your socket

You can close your open socket when you no longer need it by using `metrics.<span class="apidocCodeKeywordSpan">close</span>()`.

### Errors

By default `errors` get logged. If you wish to change this behavior simply specify a `on_error` function when instantiating the `
lynx` client.

``` js
function on_error(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.count" id="apidoc.element.lynx.lynx.prototype.count">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>count
        <span class="apidocSignatureSpan">(stats, delta, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(stats, delta, sample_rate) {
  //
  // If we are given a string stat (key) then transform it into array
  //
  if (typeof stats === 'string') {
    stats = [stats];
  }

  //
  // By now stats must be an array
  //
  if(!Array.isArray(stats)) {
    //
    // Error: Can't set if its not even an array by now
    //
    this.on_error(
      makeError({ message : "Can't set if its not even an array by now"
      , f       : 'count'
      , args    : arguments
      }));
    return;
  }

  //
  // Delta is required and must exist or we will send crap to statsd
  //
  if (typeof delta!=='number' &amp;&amp; typeof delta!=='string' || isNaN(delta)) {
    //
    // Error: Must be either a number or a string, we cant send other stuff
    //
    this.on_error(
      makeError({ message : 'Must be either a number or a string'
      , f       : 'count'
      , args    : arguments
      }));
    return;
  }

  //
  // Batch up all these stats to send
  //
  var batch = {};
  for(var i in stats) {
    batch[stats[i]] = delta + '|c';
  }

  //
  // Send all these stats
  //
  this.send(batch, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.createTimer" id="apidoc.element.lynx.lynx.prototype.createTimer">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>createTimer
        <span class="apidocSignatureSpan">(stat, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTimer(stat, sample_rate) {
  var self       = this
    , start_time = new Date ().getTime()
    , stopped    = false
    , duration
    , start_hrtime
    ;

  if (typeof process.hrtime === "function") {
    var start_hrtime = process.hrtime();
  }

  //
  // ### function stop()
  //
  // Stops the timer and issues the respective interval.
  // Check example above
  //
  function stop() {
    //
    // If timer is already stopped just ignore the request
    //
    if(stopped) {
      self.on_error(
        makeError({ message : "Can't stop a timer twice"
        , f       : 'stop'
        }));
      return;
    }

    //
    // Calculate duration
    //
    if (start_hrtime) {
      var stop_hrtime = process.hrtime()
        , seconds     = stop_hrtime[0] - start_hrtime[0]
        , nanos       = stop_hrtime[1] - start_hrtime[1]
        ;
      duration = seconds * 1000 + nanos / 1000000
    } else {
      duration = new Date ().getTime() - start_time;
    }

    //
    // Emit
    //
    self.timing(stat, duration, sample_rate);

    //
    // So no one stops a timer twice (causing two emits)
    //
    stopped = true;
  }

  //
  // The closure that is returned
  //
  return {
      stat        : stat
    , sample_rate : sample_rate
    , start_time  : start_time
    , stop        : stop
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
var metrics = new lynx('localhost', 8125);
metrics.increment('node_test.int', 0.1);
metrics.decrement('node_test.int', 0.1);
metrics.timing('node_test.some_service.task.time', 500, 0.1);
metrics.gauge('gauge.one', 100, 0.1);
metrics.set('set.one', 10, 0.1);
var timer2 = metrics.<span class="apidocCodeKeywordSpan">createTimer</span>('node_test.some_service.task2.time', 0.1);
timer2.stop();
```

### Streams

You can stream to `lynx`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.decrement" id="apidoc.element.lynx.lynx.prototype.decrement">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>decrement
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrement(stats, sample_rate) {
  this.count(stats, -1, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   * `scope` to define the a prefix for all stats, e.g. with `scope`
//     'product1' and stat 'somestat' the key would actually be
//     'product1.somestat'
//
&gt; var metrics = new lynx('localhost', 8125);
{ host: 'localhost', port: 8125 }
&gt; metrics.increment('node_test.int');
&gt; metrics.<span class="apidocCodeKeywordSpan">decrement</span>('node_test.int');
&gt; metrics.timing('node_test.some_service.task.time', 500); // time in ms
&gt; metrics.gauge('gauge.one', 100);
&gt; metrics.set('set.one', 10);
```

This is the equivalent to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.destroy" id="apidoc.element.lynx.lynx.prototype.destroy">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy() {
  this.writable = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.end" id="apidoc.element.lynx.lynx.prototype.end">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>end
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end(buffer) {
  //
  // If there's stuff to flush please do
  //
  if (arguments.length) {
    this.write(buffer);
  }

  //
  // Make this not writable
  //
  this.writable = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.gauge" id="apidoc.element.lynx.lynx.prototype.gauge">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>gauge
        <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gauge(stat, value, sample_rate) {
  var stats   = {};
  stats[stat] = value + '|g';
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     'product1.somestat'
//
&gt; var metrics = new lynx('localhost', 8125);
{ host: 'localhost', port: 8125 }
&gt; metrics.increment('node_test.int');
&gt; metrics.decrement('node_test.int');
&gt; metrics.timing('node_test.some_service.task.time', 500); // time in ms
&gt; metrics.<span class="apidocCodeKeywordSpan">gauge</span>('gauge.one', 100);
&gt; metrics.set('set.one', 10);
```

This is the equivalent to:

``` sh
echo "node_test.int:1|c"  | nc -w 0 -u localhost 8125
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.increment" id="apidoc.element.lynx.lynx.prototype.increment">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>increment
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function increment(stats, sample_rate) {
  this.count(stats, 1, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   * `socket` if you wish to just use a existing udp socket
//   * `scope` to define the a prefix for all stats, e.g. with `scope`
//     'product1' and stat 'somestat' the key would actually be
//     'product1.somestat'
//
&gt; var metrics = new lynx('localhost', 8125);
{ host: 'localhost', port: 8125 }
&gt; metrics.<span class="apidocCodeKeywordSpan">increment</span>('node_test.int');
&gt; metrics.decrement('node_test.int');
&gt; metrics.timing('node_test.some_service.task.time', 500); // time in ms
&gt; metrics.gauge('gauge.one', 100);
&gt; metrics.set('set.one', 10);
```

This is the equivalent to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.send" id="apidoc.element.lynx.lynx.prototype.send">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>send
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(stats, sample_rate) {
  var self          = this
    , sampled_stats = Lynx.sample(stats, sample_rate)
    , all_stats     = Object.keys(sampled_stats)
    //
    // Data to be sent
    //
    , send_data
    ;

  //
  // If this object is empty (enumerable properties)
  //
  if(all_stats.length === 0) {
    //
    // Error: Nothing to send
    //
    this.on_error(
      makeError({ message : 'Nothing to send'
      , f       : 'send'
      , args    : arguments
      }));
    return;
  }

  //
  // Construct our send request
  // If we have multiple stats send them in the same udp package
  // This is achieved by having newline separated stats.
  //
  send_data = all_stats.map(function construct_stat(stat) {
    return self.scope + stat + ':' + sampled_stats[stat];
  }).join('\n');

  //
  // Encode our data to a buffer
  //
  var buffer = new Buffer(send_data, 'utf8')
    , socket
    ;

  //
  // Do we already have a socket object we can use?
  //
  if (this.socket === undefined) {
    //
    // Do we have an ephemeral socket we can use?
    //
    if (!this.ephemeral_socket) {
      //
      // Create one
      //
      this.ephemeral_socket = dgram.createSocket('udp4');

      //
      // Register on error: Failed sending the buffer
      //
      this.ephemeral_socket.on('error', function (err) {
        err.reason  = err.message;
        err.f       = 'send';
        err.message = 'Failed sending the buffer';
        err.args    = arguments;
        self.on_error(err);
        return;
      });
    }

    socket = this.ephemeral_socket;
  } else {
    //
    // Reuse our socket
    //
    socket = this.socket;
  }

  //
  // Update the last time this socket was used
  // This is used to make the socket ephemeral
  //
  this._update_last_used();

  //
  // Send the data
  //
  this.emit('data', buffer);
  socket.send(buffer, 0, buffer.length, this.port, this.host, noop);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// This code is only to exemplify the functionality
//
// As of the current implementation the sample rate is processed per group
// of stats and not per individual stat, meaning either all would be send
// or none would be sent.
//
metrics.<span class="apidocCodeKeywordSpan">send</span>(
  { "foo" : "-1|c"    // count
  , "bar" : "15|g"    // gauge
  , "baz" : "500|ms"  // timing
  , "boaz": "40|s"    // set
  }, 0.1);            // sample rate at `0.1`
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.set" id="apidoc.element.lynx.lynx.prototype.set">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>set
        <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(stat, value, sample_rate) {
  var stats   = {};
  stats[stat] = value + '|s';
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
&gt; var metrics = new lynx('localhost', 8125);
{ host: 'localhost', port: 8125 }
&gt; metrics.increment('node_test.int');
&gt; metrics.decrement('node_test.int');
&gt; metrics.timing('node_test.some_service.task.time', 500); // time in ms
&gt; metrics.gauge('gauge.one', 100);
&gt; metrics.<span class="apidocCodeKeywordSpan">set</span>('set.one', 10);
```

This is the equivalent to:

``` sh
echo "node_test.int:1|c"  | nc -w 0 -u localhost 8125
echo "node_test.int:-1|c" | nc -w 0 -u localhost 8125
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.timing" id="apidoc.element.lynx.lynx.prototype.timing">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>timing
        <span class="apidocSignatureSpan">(stat, duration, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timing(stat, duration, sample_rate) {
  var stats   = {};
  stats[stat] = duration + '|ms';
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     'product1' and stat 'somestat' the key would actually be
//     'product1.somestat'
//
&gt; var metrics = new lynx('localhost', 8125);
{ host: 'localhost', port: 8125 }
&gt; metrics.increment('node_test.int');
&gt; metrics.decrement('node_test.int');
&gt; metrics.<span class="apidocCodeKeywordSpan">timing</span>('node_test.some_service.task.time', 500); // time in
ms
&gt; metrics.gauge('gauge.one', 100);
&gt; metrics.set('set.one', 10);
```

This is the equivalent to:

``` sh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.write" id="apidoc.element.lynx.lynx.prototype.write">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>write
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(buffer) {
  this.parser.write(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>