<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/dscape/lynx"

    >lynx (v0.2.0)</a>
</h1>
<h4>Minimalistic StatsD client for Node.js programs</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx">module lynx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx">
            function <span class="apidocSignatureSpan"></span>lynx
            <span class="apidocSignatureSpan">(host, port, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.sample">
            function <span class="apidocSignatureSpan">lynx.</span>sample
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.super_">
            function <span class="apidocSignatureSpan">lynx.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">lynx.</span>lynx.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx.lynx">module lynx.lynx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.lynx">
            function <span class="apidocSignatureSpan">lynx.</span>lynx
            <span class="apidocSignatureSpan">(host, port, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.sample">
            function <span class="apidocSignatureSpan">lynx.lynx.</span>sample
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.super_">
            function <span class="apidocSignatureSpan">lynx.lynx.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.lynx.lynx.prototype">module lynx.lynx.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype._default_error_handler">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_default_error_handler
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype._update_last_used">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_update_last_used
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.close">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.count">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>count
            <span class="apidocSignatureSpan">(stats, delta, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.createTimer">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>createTimer
            <span class="apidocSignatureSpan">(stat, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.decrement">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>decrement
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.destroy">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.end">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>end
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.gauge">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>gauge
            <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.increment">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>increment
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.send">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>send
            <span class="apidocSignatureSpan">(stats, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.set">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>set
            <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.timing">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>timing
            <span class="apidocSignatureSpan">(stat, duration, sample_rate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.lynx.lynx.prototype.write">
            function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>write
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx" id="apidoc.module.lynx">module lynx</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx" id="apidoc.element.lynx.lynx">
        function <span class="apidocSignatureSpan"></span>lynx
        <span class="apidocSignatureSpan">(host, port, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lynx(host, port, options) {
  if (!(this instanceof Lynx)) {
    return new Lynx(host, port, options);
  }

  var self = this;

  //
  // Server hostname and port
  //
  this.host = host || &#x27;127.0.0.1&#x27;;
  this.port = port || 8125;

  //
  // Optional shared socket
  //
  this.socket = options &#x26;&#x26; options.socket;

  //
  // Handle prefix
  //
  this.scope = options &#x26;&#x26; options.scope || options &#x26;&#x26; options.prefix || &#x27;&#x27;;

  //
  // groups in graphite are delimited by `.` so we need to make sure our
  // scope ends with `.`. If it doesn&#x27;t we just add it (unless we have no
  // scope defined).
  //
  if(typeof this.scope === &#x27;string&#x27; &#x26;&#x26; this.scope !== &#x27;&#x27; &#x26;&#x26;
     !/\.$/.test(this.scope)) {
    this.scope += &#x27;.&#x27;;
  }

  //
  // When a *shared* socked isn&#x27;t provided, an ephemeral
  // socket is demand allocated.  This ephemeral socket is closed
  // after being idle for EPHEMERAL_LIFETIME_MS.
  //
  this.ephemeral_socket = undefined;
  this.last_used_timer  = undefined;

  //
  // Set out error handling code
  //
  this.on_error = options &#x26;&#x26; typeof options.on_error === &#x27;function&#x27;
               ? options.on_error
               : this._default_error_handler
               ;

  //
  // Stream properties
  //
  this.readable = true;
  this.writable = true;

  this.parser = parser.createStream();

  this.parser.on(&#x27;error&#x27;, this.on_error);

  this.parser.on(&#x27;stat&#x27;, function (text, stat_obj) {
    var stat = {};

    //
    // Construct a statsd value|type pair
    //
    stat[stat_obj.stat] = stat_obj.value + &#x27;|&#x27; + stat_obj.type;

    //
    // Add sample rate if one exists
    //
    if(stat_obj.sample_rate) {
      stat[stat_obj.stat] += &#x27;@&#x27; + stat_obj.sample_rate;
      self.send(stat, parseFloat(stat_obj.sample_rate));
    }
    else {
      self.send(stat);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.sample" id="apidoc.element.lynx.sample">
        function <span class="apidocSignatureSpan">lynx.</span>sample
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(stats, sample_rate) {
  //
  // If we don&#x27;t have a sample rate between 0 and 1
  //
  if (typeof sample_rate !== &#x27;number&#x27; || sample_rate &#x3e; 1 || sample_rate &#x3c; 0) {
    //
    // Had to ignore the invalid sample rate
    // Most of the times this is because sample_rate is undefined
    //
    return stats;
  }

  var sampled_stats = {};

  //
  // Randomly determine if we should sample this specific instance
  //
  if (mt.genrand_real2(0,1) &#x3c;= sample_rate) {
    //
    // Note: Current implementation either sends all stats for a specific
    //       sample rate or sends none. Makes one wonder if granularity
    //       should be at the individual stat level
    //
    Object.keys(stats).forEach(function construct_sampled(stat) {
      var value = stats[stat];
      sampled_stats[stat] = value + &#x27;|@&#x27; + sample_rate;
    });
  }

  return sampled_stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.super_" id="apidoc.element.lynx.super_">
        function <span class="apidocSignatureSpan">lynx.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx.lynx" id="apidoc.module.lynx.lynx">module lynx.lynx</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx.lynx" id="apidoc.element.lynx.lynx.lynx">
        function <span class="apidocSignatureSpan">lynx.</span>lynx
        <span class="apidocSignatureSpan">(host, port, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lynx(host, port, options) {
  if (!(this instanceof Lynx)) {
    return new Lynx(host, port, options);
  }

  var self = this;

  //
  // Server hostname and port
  //
  this.host = host || &#x27;127.0.0.1&#x27;;
  this.port = port || 8125;

  //
  // Optional shared socket
  //
  this.socket = options &#x26;&#x26; options.socket;

  //
  // Handle prefix
  //
  this.scope = options &#x26;&#x26; options.scope || options &#x26;&#x26; options.prefix || &#x27;&#x27;;

  //
  // groups in graphite are delimited by `.` so we need to make sure our
  // scope ends with `.`. If it doesn&#x27;t we just add it (unless we have no
  // scope defined).
  //
  if(typeof this.scope === &#x27;string&#x27; &#x26;&#x26; this.scope !== &#x27;&#x27; &#x26;&#x26;
     !/\.$/.test(this.scope)) {
    this.scope += &#x27;.&#x27;;
  }

  //
  // When a *shared* socked isn&#x27;t provided, an ephemeral
  // socket is demand allocated.  This ephemeral socket is closed
  // after being idle for EPHEMERAL_LIFETIME_MS.
  //
  this.ephemeral_socket = undefined;
  this.last_used_timer  = undefined;

  //
  // Set out error handling code
  //
  this.on_error = options &#x26;&#x26; typeof options.on_error === &#x27;function&#x27;
               ? options.on_error
               : this._default_error_handler
               ;

  //
  // Stream properties
  //
  this.readable = true;
  this.writable = true;

  this.parser = parser.createStream();

  this.parser.on(&#x27;error&#x27;, this.on_error);

  this.parser.on(&#x27;stat&#x27;, function (text, stat_obj) {
    var stat = {};

    //
    // Construct a statsd value|type pair
    //
    stat[stat_obj.stat] = stat_obj.value + &#x27;|&#x27; + stat_obj.type;

    //
    // Add sample rate if one exists
    //
    if(stat_obj.sample_rate) {
      stat[stat_obj.stat] += &#x27;@&#x27; + stat_obj.sample_rate;
      self.send(stat, parseFloat(stat_obj.sample_rate));
    }
    else {
      self.send(stat);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.sample" id="apidoc.element.lynx.lynx.sample">
        function <span class="apidocSignatureSpan">lynx.lynx.</span>sample
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(stats, sample_rate) {
  //
  // If we don&#x27;t have a sample rate between 0 and 1
  //
  if (typeof sample_rate !== &#x27;number&#x27; || sample_rate &#x3e; 1 || sample_rate &#x3c; 0) {
    //
    // Had to ignore the invalid sample rate
    // Most of the times this is because sample_rate is undefined
    //
    return stats;
  }

  var sampled_stats = {};

  //
  // Randomly determine if we should sample this specific instance
  //
  if (mt.genrand_real2(0,1) &#x3c;= sample_rate) {
    //
    // Note: Current implementation either sends all stats for a specific
    //       sample rate or sends none. Makes one wonder if granularity
    //       should be at the individual stat level
    //
    Object.keys(stats).forEach(function construct_sampled(stat) {
      var value = stats[stat];
      sampled_stats[stat] = value + &#x27;|@&#x27; + sample_rate;
    });
  }

  return sampled_stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.super_" id="apidoc.element.lynx.lynx.super_">
        function <span class="apidocSignatureSpan">lynx.lynx.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.lynx.lynx.prototype" id="apidoc.module.lynx.lynx.prototype">module lynx.lynx.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype._default_error_handler" id="apidoc.element.lynx.lynx.prototype._default_error_handler">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_default_error_handler
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _default_error_handler(e) {
  this.emit(&#x27;error&#x27;, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype._update_last_used" id="apidoc.element.lynx.lynx.prototype._update_last_used">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>_update_last_used
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _update_last_used() {
  var self = this;

  //
  // Only update on the ephemeral socket
  //
  if (this.ephemeral_socket) {
    //
    // Clear existing timeouts
    //
    if (this.last_used_timer) {
      clearTimeout(this.last_used_timer);
    }

    //
    // Update last_used_timer
    //
    this.last_used_timer = setTimeout(function() {
      //
      // If we have an open socket close it
      //
      if (self.ephemeral_socket) {
        self.ephemeral_socket.close();
      }

      //
      // Delete the socket
      //
      delete self.ephemeral_socket;
    }, EPHEMERAL_LIFETIME_MS);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.close" id="apidoc.element.lynx.lynx.prototype.close">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close() {
  //
  // User defined socket
  //
  if (this.socket) {
    this.socket.close();
    this.socket = undefined;
  }

  //
  // Ephemeral socket
  //
  if (this.ephemeral_socket) {
    this.ephemeral_socket.close();
    this.ephemeral_socket = undefined;
  }

  //
  // Timer
  //
  if (this.last_used_timer) {
    clearTimeout(this.last_used_timer);
    this.last_used_timer = undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , &#x22;baz&#x22; : &#x22;500|ms&#x22;  // timing
  , &#x22;boaz&#x22;: &#x22;40|s&#x22;    // set
  }, 0.1);            // sample rate at `0.1`
```

### Closing your socket

You can close your open socket when you no longer need it by using `metrics.<span class="apidocCodeKeywordSpan">close</span>()`.

### Errors

By default `errors` get logged. If you wish to change this behavior simply specify a `on_error` function when instantiating the `
lynx` client.

``` js
function on_error(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.count" id="apidoc.element.lynx.lynx.prototype.count">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>count
        <span class="apidocSignatureSpan">(stats, delta, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(stats, delta, sample_rate) {
  //
  // If we are given a string stat (key) then transform it into array
  //
  if (typeof stats === &#x27;string&#x27;) {
    stats = [stats];
  }

  //
  // By now stats must be an array
  //
  if(!Array.isArray(stats)) {
    //
    // Error: Can&#x27;t set if its not even an array by now
    //
    this.on_error(
      makeError({ message : &#x22;Can&#x27;t set if its not even an array by now&#x22;
      , f       : &#x27;count&#x27;
      , args    : arguments
      }));
    return;
  }

  //
  // Delta is required and must exist or we will send crap to statsd
  //
  if (typeof delta!==&#x27;number&#x27; &#x26;&#x26; typeof delta!==&#x27;string&#x27; || isNaN(delta)) {
    //
    // Error: Must be either a number or a string, we cant send other stuff
    //
    this.on_error(
      makeError({ message : &#x27;Must be either a number or a string&#x27;
      , f       : &#x27;count&#x27;
      , args    : arguments
      }));
    return;
  }

  //
  // Batch up all these stats to send
  //
  var batch = {};
  for(var i in stats) {
    batch[stats[i]] = delta + &#x27;|c&#x27;;
  }

  //
  // Send all these stats
  //
  this.send(batch, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.createTimer" id="apidoc.element.lynx.lynx.prototype.createTimer">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>createTimer
        <span class="apidocSignatureSpan">(stat, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTimer(stat, sample_rate) {
  var self       = this
    , start_time = new Date ().getTime()
    , stopped    = false
    , duration
    , start_hrtime
    ;

  if (typeof process.hrtime === &#x22;function&#x22;) {
    var start_hrtime = process.hrtime();
  }

  //
  // ### function stop()
  //
  // Stops the timer and issues the respective interval.
  // Check example above
  //
  function stop() {
    //
    // If timer is already stopped just ignore the request
    //
    if(stopped) {
      self.on_error(
        makeError({ message : &#x22;Can&#x27;t stop a timer twice&#x22;
        , f       : &#x27;stop&#x27;
        }));
      return;
    }

    //
    // Calculate duration
    //
    if (start_hrtime) {
      var stop_hrtime = process.hrtime()
        , seconds     = stop_hrtime[0] - start_hrtime[0]
        , nanos       = stop_hrtime[1] - start_hrtime[1]
        ;
      duration = seconds * 1000 + nanos / 1000000
    } else {
      duration = new Date ().getTime() - start_time;
    }

    //
    // Emit
    //
    self.timing(stat, duration, sample_rate);

    //
    // So no one stops a timer twice (causing two emits)
    //
    stopped = true;
  }

  //
  // The closure that is returned
  //
  return {
      stat        : stat
    , sample_rate : sample_rate
    , start_time  : start_time
    , stop        : stop
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
var metrics = new lynx(&#x27;localhost&#x27;, 8125);
metrics.increment(&#x27;node_test.int&#x27;, 0.1);
metrics.decrement(&#x27;node_test.int&#x27;, 0.1);
metrics.timing(&#x27;node_test.some_service.task.time&#x27;, 500, 0.1);
metrics.gauge(&#x27;gauge.one&#x27;, 100, 0.1);
metrics.set(&#x27;set.one&#x27;, 10, 0.1);
var timer2 = metrics.<span class="apidocCodeKeywordSpan">createTimer</span>(&#x27;node_test.some_service.task2.time&#x27;, 0.1);
timer2.stop();
```

### Streams

You can stream to `lynx`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.decrement" id="apidoc.element.lynx.lynx.prototype.decrement">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>decrement
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrement(stats, sample_rate) {
  this.count(stats, -1, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   * `scope` to define the a prefix for all stats, e.g. with `scope`
//     &#x27;product1&#x27; and stat &#x27;somestat&#x27; the key would actually be
//     &#x27;product1.somestat&#x27;
//
&#x3e; var metrics = new lynx(&#x27;localhost&#x27;, 8125);
{ host: &#x27;localhost&#x27;, port: 8125 }
&#x3e; metrics.increment(&#x27;node_test.int&#x27;);
&#x3e; metrics.<span class="apidocCodeKeywordSpan">decrement</span>(&#x27;node_test.int&#x27;);
&#x3e; metrics.timing(&#x27;node_test.some_service.task.time&#x27;, 500); // time in ms
&#x3e; metrics.gauge(&#x27;gauge.one&#x27;, 100);
&#x3e; metrics.set(&#x27;set.one&#x27;, 10);
```

This is the equivalent to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.destroy" id="apidoc.element.lynx.lynx.prototype.destroy">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy() {
  this.writable = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.end" id="apidoc.element.lynx.lynx.prototype.end">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>end
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end(buffer) {
  //
  // If there&#x27;s stuff to flush please do
  //
  if (arguments.length) {
    this.write(buffer);
  }

  //
  // Make this not writable
  //
  this.writable = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.gauge" id="apidoc.element.lynx.lynx.prototype.gauge">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>gauge
        <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gauge(stat, value, sample_rate) {
  var stats   = {};
  stats[stat] = value + &#x27;|g&#x27;;
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     &#x27;product1.somestat&#x27;
//
&#x3e; var metrics = new lynx(&#x27;localhost&#x27;, 8125);
{ host: &#x27;localhost&#x27;, port: 8125 }
&#x3e; metrics.increment(&#x27;node_test.int&#x27;);
&#x3e; metrics.decrement(&#x27;node_test.int&#x27;);
&#x3e; metrics.timing(&#x27;node_test.some_service.task.time&#x27;, 500); // time in ms
&#x3e; metrics.<span class="apidocCodeKeywordSpan">gauge</span>(&#x27;gauge.one&#x27;, 100);
&#x3e; metrics.set(&#x27;set.one&#x27;, 10);
```

This is the equivalent to:

``` sh
echo &#x22;node_test.int:1|c&#x22;  | nc -w 0 -u localhost 8125
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.increment" id="apidoc.element.lynx.lynx.prototype.increment">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>increment
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function increment(stats, sample_rate) {
  this.count(stats, 1, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   * `socket` if you wish to just use a existing udp socket
//   * `scope` to define the a prefix for all stats, e.g. with `scope`
//     &#x27;product1&#x27; and stat &#x27;somestat&#x27; the key would actually be
//     &#x27;product1.somestat&#x27;
//
&#x3e; var metrics = new lynx(&#x27;localhost&#x27;, 8125);
{ host: &#x27;localhost&#x27;, port: 8125 }
&#x3e; metrics.<span class="apidocCodeKeywordSpan">increment</span>(&#x27;node_test.int&#x27;);
&#x3e; metrics.decrement(&#x27;node_test.int&#x27;);
&#x3e; metrics.timing(&#x27;node_test.some_service.task.time&#x27;, 500); // time in ms
&#x3e; metrics.gauge(&#x27;gauge.one&#x27;, 100);
&#x3e; metrics.set(&#x27;set.one&#x27;, 10);
```

This is the equivalent to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.send" id="apidoc.element.lynx.lynx.prototype.send">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>send
        <span class="apidocSignatureSpan">(stats, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(stats, sample_rate) {
  var self          = this
    , sampled_stats = Lynx.sample(stats, sample_rate)
    , all_stats     = Object.keys(sampled_stats)
    //
    // Data to be sent
    //
    , send_data
    ;

  //
  // If this object is empty (enumerable properties)
  //
  if(all_stats.length === 0) {
    //
    // Error: Nothing to send
    //
    this.on_error(
      makeError({ message : &#x27;Nothing to send&#x27;
      , f       : &#x27;send&#x27;
      , args    : arguments
      }));
    return;
  }

  //
  // Construct our send request
  // If we have multiple stats send them in the same udp package
  // This is achieved by having newline separated stats.
  //
  send_data = all_stats.map(function construct_stat(stat) {
    return self.scope + stat + &#x27;:&#x27; + sampled_stats[stat];
  }).join(&#x27;\n&#x27;);

  //
  // Encode our data to a buffer
  //
  var buffer = new Buffer(send_data, &#x27;utf8&#x27;)
    , socket
    ;

  //
  // Do we already have a socket object we can use?
  //
  if (this.socket === undefined) {
    //
    // Do we have an ephemeral socket we can use?
    //
    if (!this.ephemeral_socket) {
      //
      // Create one
      //
      this.ephemeral_socket = dgram.createSocket(&#x27;udp4&#x27;);

      //
      // Register on error: Failed sending the buffer
      //
      this.ephemeral_socket.on(&#x27;error&#x27;, function (err) {
        err.reason  = err.message;
        err.f       = &#x27;send&#x27;;
        err.message = &#x27;Failed sending the buffer&#x27;;
        err.args    = arguments;
        self.on_error(err);
        return;
      });
    }

    socket = this.ephemeral_socket;
  } else {
    //
    // Reuse our socket
    //
    socket = this.socket;
  }

  //
  // Update the last time this socket was used
  // This is used to make the socket ephemeral
  //
  this._update_last_used();

  //
  // Send the data
  //
  this.emit(&#x27;data&#x27;, buffer);
  socket.send(buffer, 0, buffer.length, this.port, this.host, noop);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// This code is only to exemplify the functionality
//
// As of the current implementation the sample rate is processed per group
// of stats and not per individual stat, meaning either all would be send
// or none would be sent.
//
metrics.<span class="apidocCodeKeywordSpan">send</span>(
  { &#x22;foo&#x22; : &#x22;-1|c&#x22;    // count
  , &#x22;bar&#x22; : &#x22;15|g&#x22;    // gauge
  , &#x22;baz&#x22; : &#x22;500|ms&#x22;  // timing
  , &#x22;boaz&#x22;: &#x22;40|s&#x22;    // set
  }, 0.1);            // sample rate at `0.1`
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.set" id="apidoc.element.lynx.lynx.prototype.set">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>set
        <span class="apidocSignatureSpan">(stat, value, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(stat, value, sample_rate) {
  var stats   = {};
  stats[stat] = value + &#x27;|s&#x27;;
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
&#x3e; var metrics = new lynx(&#x27;localhost&#x27;, 8125);
{ host: &#x27;localhost&#x27;, port: 8125 }
&#x3e; metrics.increment(&#x27;node_test.int&#x27;);
&#x3e; metrics.decrement(&#x27;node_test.int&#x27;);
&#x3e; metrics.timing(&#x27;node_test.some_service.task.time&#x27;, 500); // time in ms
&#x3e; metrics.gauge(&#x27;gauge.one&#x27;, 100);
&#x3e; metrics.<span class="apidocCodeKeywordSpan">set</span>(&#x27;set.one&#x27;, 10);
```

This is the equivalent to:

``` sh
echo &#x22;node_test.int:1|c&#x22;  | nc -w 0 -u localhost 8125
echo &#x22;node_test.int:-1|c&#x22; | nc -w 0 -u localhost 8125
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.timing" id="apidoc.element.lynx.lynx.prototype.timing">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>timing
        <span class="apidocSignatureSpan">(stat, duration, sample_rate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timing(stat, duration, sample_rate) {
  var stats   = {};
  stats[stat] = duration + &#x27;|ms&#x27;;
  this.send(stats, sample_rate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     &#x27;product1&#x27; and stat &#x27;somestat&#x27; the key would actually be
//     &#x27;product1.somestat&#x27;
//
&#x3e; var metrics = new lynx(&#x27;localhost&#x27;, 8125);
{ host: &#x27;localhost&#x27;, port: 8125 }
&#x3e; metrics.increment(&#x27;node_test.int&#x27;);
&#x3e; metrics.decrement(&#x27;node_test.int&#x27;);
&#x3e; metrics.<span class="apidocCodeKeywordSpan">timing</span>(&#x27;node_test.some_service.task.time&#x27;, 500); // time in
ms
&#x3e; metrics.gauge(&#x27;gauge.one&#x27;, 100);
&#x3e; metrics.set(&#x27;set.one&#x27;, 10);
```

This is the equivalent to:

``` sh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.lynx.lynx.prototype.write" id="apidoc.element.lynx.lynx.prototype.write">
        function <span class="apidocSignatureSpan">lynx.lynx.prototype.</span>write
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(buffer) {
  this.parser.write(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
